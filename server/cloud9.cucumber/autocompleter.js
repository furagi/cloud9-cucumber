// Generated by CoffeeScript 1.6.3
var AutoCompleter, async, crypto, fs, watch,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

fs = require('fs');

crypto = require('crypto');

async = require('async');

watch = require('watch');

module.exports = AutoCompleter = (function() {
    function AutoCompleter(projectDir) {
        this._onFileChanged = __bind(this._onFileChanged, this);
        var watcher,
            _this = this;
        this.phrases = {};
        this.files = {};
        watcher = watch.createMonitor(projectDir, {
            'ignoreDotFiles': true
        }, function(monitor) {
            monitor.on("created", function(file, stat) {
                if (file.split('.').pop() !== 'feature') {
                    return;
                }
                console.log('File ' + file + ' was created');
                return _this._getPhrasesFromFile(file);
            });
            monitor.on("changed", function(file, curr, prev) {
                if (file.split('.').pop() !== 'feature') {
                    return;
                }
                console.log('File ' + file + ' was changed');
                _this._removeFromIndex(file);
                return _this._getPhrasesFromFile(file);
            });
            monitor.on("removed", function(file, stat) {
                if (file.split('.').pop() !== 'feature') {
                    return;
                }
                console.log('File ' + file + ' was removed');
                if (stat.nlink === 0) {
                    return _this._removeFromIndex(file);
                }
            });
            return _this._readPath(projectDir);
        });
    }

    AutoCompleter.prototype._readPath = function(rootPath) {
        var _this = this;
        if (rootPath == null) {
            return;
        }
        return fs.stat(rootPath, function(err, stat) {
            if (err != null) {
                return console.log(err);
            }
            if (stat.isFile() && rootPath.split('.').pop() === 'feature') {
                return _this._getPhrasesFromFile(rootPath);
            }
            if (stat.isDirectory()) {
                return fs.readdir(rootPath, function(err, paths) {
                    var path, _i, _len, _results;
                    if (err != null) {
                        return console.log(err);
                    }
                    _results = [];
                    for (_i = 0, _len = paths.length; _i < _len; _i++) {
                        path = paths[_i];
                        _results.push(_this._readPath(rootPath + '/' + path));
                    }
                    return _results;
                });
            }
        });
    };

    AutoCompleter.prototype._removeFromIndex = function(path) {
        var file, hash, index, pathHash, phraseHash, phrases, _i, _len;
        hash = crypto.createHash('md5');
        hash.update(path, 'utf8');
        pathHash = hash.digest('hex');
        if (this.files[pathHash] == null) {
            return;
        }
        file = this.files[pathHash];
        phrases = file.phrases;
        for (_i = 0, _len = phrases.length; _i < _len; _i++) {
            phraseHash = phrases[_i];
            if (this.phrases[phraseHash] == null) {
                continue;
            }
            index = this.phrases[phraseHash].paths.indexOf(pathHash);
            if (index !== -1) {
                this.phrases[phraseHash].paths.splice(index, 1);
            }
        }
        return delete this.files[pathHash];
    };

    AutoCompleter.prototype._getPhrasesFromFile = function(file) {
        var _this = this;
        console.log('Read file ' + file);
        return fs.readFile(file, function(err, data) {
            var hash, pathHash, phrase, phraseHash, phrases, steps, tags, _i, _len;
            if (err != null) {
                return console.log(err);
            }
            data = data.toString();
            if (data === '') {
                return console.log('File ' + file + ' is empty');
            }
            data = data.replace(/\b[0-9]{1,}\b/g, '$d');
            steps = data.match(/(Given|When|Then|And).+/gm);
            tags = data.match(/@(\w|\W).+/gm);
            phrases = [];
            if ((tags != null) && tags.length) {
                phrases = tags;
            }
            if ((steps != null) && steps.length) {
                phrases = phrases.concat(steps);
            }
            if (phrases.length === 0) {
                return;
            }
            hash = crypto.createHash('md5');
            hash.update(file, 'utf8');
            pathHash = hash.digest('hex');
            if (_this.files[pathHash] == null) {
                _this.files[pathHash] = {
                    path: file,
                    phrases: []
                };
            }
            for (_i = 0, _len = phrases.length; _i < _len; _i++) {
                phrase = phrases[_i];
                hash = crypto.createHash('md5');
                hash.update(phrase, 'utf8');
                phraseHash = hash.digest('hex');
                if (_this.phrases[phraseHash] == null) {
                    _this.phrases[phraseHash] = {
                        paths: [pathHash],
                        phrase: phrase
                    };
                } else {
                    if (_this.phrases[phraseHash].paths.indexOf(pathHash) === -1) {
                        _this.phrases[phraseHash].paths.push(pathHash);
                    }
                }
                if (_this.files[pathHash].phrases.indexOf(phraseHash) === -1) {
                    _this.files[pathHash].phrases.push(phraseHash);
                }
            }
            console.log('Phrases is ');
            console.log(_this.phrases);
            console.log('Files is ');
            return console.log(_this.files);
        });
    };

    AutoCompleter.prototype._onFileChanged = function(event, file) {
        var _this = this;
        return fs.exists(file, function(exists) {
            if (!exists) {
                return console.log('File ' + file + ' was deleted');
            }
            return _this._getPhrasesFromFile(file);
        });
    };

    AutoCompleter.prototype.getPhrases = function(query) {
        var phraseHash, phraseObject, result, _ref;
        result = [];
        query = query.replace(/\b[0-9]{1,}\b/, '$d');
        _ref = this.phrases;
        for (phraseHash in _ref) {
            phraseObject = _ref[phraseHash];
            if (phraseObject.phrase.indexOf(query) > -1) {
                result.push(phraseObject.phrase);
            }
        }
        return result.sort(function(phrase1, phrase2) {
            if (phrase1.length < phrase2.length) {
                return 1;
            }
            return -1;
        });
    };

    return AutoCompleter;

})();
